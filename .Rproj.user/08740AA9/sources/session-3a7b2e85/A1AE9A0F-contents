#' Test reporter: interactive progress bar of errors.
#'
#' @description
#' `CacheReporter` is designed for interactive use. Its goal is to
#' give you actionable insights to help you understand the status of your
#' code. This reporter also praises you from time-to-time if all your tests
#' pass. It's the default reporter for [test_dir()].
#'
#' `ParallelProgressReporter` is very similar to `ProgressReporter`, but
#' works better for packages that want parallel tests.
#'
#' `CompactProgressReporter` is a minimal version of `ProgressReporter`
#' designed for use with single files. It's the default reporter for
#' [test_file()].
#'
#' @export
#' @family reporters
CacheReporter2 <- R6::R6Class("CacheReporter",
  inherit = testthat::ProgressReporter,
  public = list(
    
    n_cache = 0,
    ctxt_cache = "N",
    
    start_context = function(context) {
      self$ctxt_cache <- "N"
      super$start_context(context)
    },
    
    status_data = function() {
      c(super$status_data(), list(cache = self$ctxt_cache))
    },
    
    show_status = function(complete = FALSE, time = 0, pad = FALSE) {
      
      if (self$ctxt_cache == "N") {
        return(super$show_status(complete, time, pad))
      } 
      
      con <- textConnection("msg", "w")
      old <- self$out
      self$out <- con
      super$show_status(complete, time, pad)
      self$out <- old
      close(con)
      
      msg <- paste(
        style_strikethrough(ansi_trimws(msg, "right")),
        col_green(style_italic("test is cached")),
        recycle0 = TRUE
      )
      
      if (length(msg) != 0) self$cat_line(msg)
      
    },
    
    
    add_result = function(context, test, result) {
      
      if (!expectation_cache(result)) {
        return(super$add_result(context, test, result))
      }
      
      self$ctxt_n       <- self$ctxt_n + 1L
      
      self$n_cache      <- self$n_cache + 1L
      self$ctxt_cache   <- "Y"
      
      self$n_fail       <- self$n_fail + result$failure
      self$ctxt_n_fail  <- self$ctxt_n_fail + result$failure
      self$n_skip       <- self$n_skip + result$skip
      self$ctxt_n_skip  <- self$ctxt_n_skip + result$skip
      self$n_warn       <- self$n_warn + result$warn
      self$ctxt_n_warn  <- self$ctxt_n_warn + result$warn
      self$n_ok         <- self$n_ok + result$success
      self$ctxt_n_ok    <- self$ctxt_n_ok + result$success
      
      self$show_status()
      
    },
    
    end_reporter = function() {
      self$cat_line()
      
      colour_if <- function(n, type) {
        colourise(n, if (n == 0) "success" else type)
      }
      
      self$rule(cli::style_bold("Results"), line = 2)
      time <- proc.time() - self$start_time
      if (time[[3]] > self$min_time) {
        self$cat_line("Duration: ", sprintf("%.1f s", time[[3]]), col = "cyan")
        self$cat_line()
      }
      
      if (self$n_skip > 0) {
        self$rule("Skipped tests ", line = 1)
        self$cat_line(skip_bullets(self$skips$as_list()))
        self$cat_line()
      }
      
      status <- summary_line(self$n_fail, self$n_warn, self$n_skip, self$n_cache, self$n_ok)
      self$cat_line(status)
      
      if (self$is_full()) {
        self$rule("Terminated early", line = 2)
      }
      
      if (!self$show_praise || stats::runif(1) > 0.1) {
        return()
      }
      
      self$cat_line()
      if (self$n_fail == 0) {
        self$cat_line(colourise(praise(), "success"))
      } else {
        self$cat_line(colourise(encourage(), "error"))
      }
    }
  )
)

spinner <- function(frames, i) {
  frames[((i - 1) %% length(frames)) + 1]
}

strpad <- function(x, width = cli::console_width()) {
  n <- pmax(0, width - cli::ansi_nchar(x))
  paste0(x, strrep(" ", n))
}

praise <- function() {
  x <- c("Keep trying!", "Don't worry, you'll get it.", "No one is perfect!", 
         "No one gets it right on their first try", "Frustration is a natural part of programming :)", 
         "I believe in you!")
  sample(x, 1)
}

encourage <- function() {
  x <- c("Keep trying!", "Don't worry, you'll get it.", "No one is perfect!", 
         "No one gets it right on their first try", "Frustration is a natural part of programming :)", 
         "I believe in you!")
  sample(x, 1)
}

colourise <- function(text, 
                      as = c("success", "cache", "skip", "warning", "failure", "error")) {
  if (has_colour()) {
    unclass((make_ansi_style(testcache_style(as)))(text))
  }
  else {
    text
  }
}

has_colour <- function() {
  isTRUE(getOption("testthat.use_colours", TRUE)) && cli::num_ansi_colors() > 1L
}

testcache_style <- function(type = c("success", "cache", "skip", "warning", "failure", "error")) {
  type <- match.arg(type)
  c(success = "green", cache = "steelblue", skip = "blue", warning = "magenta", 
    failure = "orange", error = "orange")[[type]]
}

summary_line <- function(n_fail, n_warn, n_skip, n_cache, n_pass) {
  colourise_if <- function(text, colour, cond) {
    if (cond) colourise(text, colour) else text
  }
  
  # Ordered from most important to least important
  paste0(
    "[ ",
    colourise_if("FAIL",  "failure", n_fail  > 0), " ", n_fail,  " | ",
    colourise_if("WARN",  "warn",    n_warn  > 0), " ", n_warn,  " | ",
    colourise_if("SKIP",  "skip",    n_skip  > 0), " ", n_skip,  " | ",
    colourise_if("PASS",  "success", n_fail == 0), " ", n_pass,  " | ",
    colourise_if("CACHED", "cache", n_cache > 0), " ", n_cache,
    " ]"
  )
}

skip_bullets <- function(skips) {
  skips <- unlist(skips)
  skips <- gsub("Reason: ", "", skips)
  skips <- gsub(":?\n(\n|.)+", "", skips) # only show first line
  
  tbl <- table(skips)
  paste0(cli::symbol$bullet, " ", names(tbl), " (", tbl, ")")
}